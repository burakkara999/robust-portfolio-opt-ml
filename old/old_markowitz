def solve_markowitz_robust(assets, expected_returns, Sigma, Lambda, kappa, delta):
    """ 
    Parameters:
        -expected returns: array with size=len(assets)
        -Sigma: Covariances of returns - from past returns (NxN)
        -Lambda: Covariance of prediction errors (residuals) of returns (NxN)
        -kappa: Penalty parameter for return uncertainty
        -delta: Penalty parameter for risk - sqrt(p/(1-p))
    """
    rhat = np.asarray(expected_returns, dtype=float).reshape(-1)
    Sigma = np.asarray(Sigma, dtype=float)
    Lambda = np.asarray(Lambda, dtype=float)

    n = len(assets)
    assert rhat.shape == (n,)
    assert Sigma.shape == (n, n)
    assert Lambda.shape == (n, n)

    m = gp.Model("robust_markowitz_photo")

    # -------------------------
    # Variables
    # -------------------------
    w = m.addVars(n, lb=0.0, ub=1.0, name="w")  # 0 <= w_i <= 1
    t_r = m.addVar(lb=0.0, name="t_r")          # >= 0
    t_s = m.addVar(lb=0.0, name="t_s")          # >= 0  (this is your t_Î£)

    # -------------------------
    # Constraints
    # -------------------------
    # sum_i w_i = 1
    m.addConstr(gp.quicksum(w[i] for i in range(n)) == 1.0, name="budget")

    # w^T Lambda w <= t_r^2
    m.addQConstr(
        gp.quicksum(Lambda[i, j] * w[i] * w[j] for i in range(n) for j in range(n))
        <= t_r * t_r,
        name="mean_uncertainty"
    )

    # w^T Sigma w <= t_s^2
    m.addQConstr(
        gp.quicksum(Sigma[i, j] * w[i] * w[j] for i in range(n) for j in range(n))
        <= t_s * t_s,
        name="risk"
    )

    # -------------------------
    # Objective: max rhat^T w - kappa t_r - delta t_s
    # -------------------------
    m.setObjective(
        gp.quicksum(rhat[i] * w[i] for i in range(n)) - kappa * t_r - delta * t_s,
        GRB.MAXIMIZE
    )

    m.optimize()

    if m.Status != GRB.OPTIMAL:
        raise RuntimeError(f"Optimization status: {m.Status}")

    w_sol = np.array([w[i].X for i in range(n)], dtype=float)
    # zero-out tiny weights
    w_sol[np.abs(w_sol) < 1e-5] = 0.0

    # (optional but recommended) renormalize if sum should be 1
    s = w_sol.sum()
    if s > 0:
        w_sol = w_sol / s
    obj_val = float(m.ObjVal)
    
    return w_sol, obj_val

import numpy as np
import gurobipy as gp
from gurobipy import GRB